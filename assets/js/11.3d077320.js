(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{285:function(n,e,t){"use strict";t.r(e);var o=t(10),s=Object(o.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"_1-vue-extend"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-extend"}},[n._v("#")]),n._v(" 1.Vue.extend")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("使用基础 Vue 构造器，创建一个“子类”\n场景:vue 组件中有些需要将一些元素挂载到元素上,这个时候 extend 就起到作用了\nVue.extend实际是创建一个构造器,对应的初始化构造器,并将其挂载到标签上   是构造一个组件的语法器 \n像是我们在JS中使用的构造函数，先定义好，然后在需要使用的地方new一下\n\n为什么使用 extend\n在 vue 项目中，我们有了初始化的根实例后，所有页面基本上都是通过 router 来管理，组件也是通过 import 来进行局部注册，所以组件的创建我们不需要去关注，相比 extend 要更省心一点点。但是这样做会有几个缺点：\n\n组件模板都是事先定义好的，如果我要从接口动态渲染组件怎么办？\n所有内容都是在 #app 下渲染，注册组件都是在当前位置渲染。如果我要实现一个类似于 window.alert() 提示组件要求像调用 JS 函数一样调用它，该怎么办？\n这时候，Vue.extend + vm.$mount 组合就派上用场了。\n\n写法:\n// 创建构造器\nvar Profile = Vue.extend({\n  template: '<p>{{extendData}}</br>实例传入的数据为:{{propsExtend}}</p>',//template对应的标签最外层必须只有一个标签\n  data: function () {\n    return {\n      extendData: '这是extend扩展的数据',\n    }\n  },\n  mounted() {\n\t\tsetTimeout(() => {\n\t\t\t// 3s 后通过父级移除子元素的方式移除该组件实例和DOM节点\n\t\t\tthis.$destroy();\n\t\t\tthis.$el.parentNode.removeChild(this.$el);\n\t\t}, 3000);\n\t}\n  props:['propsExtend']\n})\n\n// 创建的构造器可以挂载到元素上,也可以通过 components 或 Vue.component()注册使用\n// 挂载到一个元素上。通过propsData传参.\nnew Profile({propsData:{propsExtend:'我是实例传入的数据'}}).$mount('#app-extend')\n$mount('要添加到的容器') 如果不传入选择器，将渲染为文档之外的的元素，不可为html或body标签\n但是可以\ninstance = new Profile({propsData:{propsExtend:'我是实例传入的数据'}});     document.body.appendChild(instance.$mount().$el);\n示例：\n\t//message.js\n\timport Vue from \"vue\"\n    import message from './message.vue'\n    let MessageContructor  = Vue.extend(message)\n    let instance\n    let Message = function(options = {}){\n        instance = new MessageContructor({propsData:{propsExtend:'我是实例传入的数据'}});\n        document.body.appendChild(instance.$mount().$el);\n    }\n\n    export default Message;\n    //main.js\n    import Message from '@/components/message'\n\tVue.prototype.$message = Message\n\n或者\n// 通过 components(局部组件注册) 或 Vue.component()注册\nVue.component('Profile',Profile)\n\n")])])]),e("h2",{attrs:{id:"_2-vue-component"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue-component"}},[n._v("#")]),n._v(" 2.Vue.component")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("1.将通过 Vue.extend 生成的扩展实例构造器注册（命名）为一个全局组件,参数可以是Vue.extend()扩展的实例,也可以是一个对象(会自动调用extend方法) 2.两个参数,一个组件名,一个extend构造器或者对象\n//1.创建组件构造器\n  var obj = {\n    props: [],\n    template: '<div><p>{{extendData}}</p></div>',//最外层只能有一个大盒子,这个和<tempalte>对应规则一致\n    data: function () {\n      return {\n        extendData: '这是Vue.component传入Vue.extend注册的组件',\n      }\n    },\n  };\n \n  var Profile = Vue.extend(obj);\n \n  //2.注册组件方法一:传入Vue.extend扩展过得构造器\n  Vue.component('component-one', Profile)\n \n  //2.注册组件方法二:直接传入\n  Vue.component('component-two', obj)\n \n  //3.挂载\n  new Vue({\n    el: '#app',\n    components:{\n    \t\n    }\n  });\n //脚手架中\n方法1\n    // 引入\n    import 组件名 from '@/components/xxx'\n    // 注册为全局组件\n    Vue.component('组件名',组件名)\n方法2\n\t在src/components文件夹下新建index.js文件\n \t// 引入写好的全局组件\n    import 组件名1 from './xxx'\n    import 组件名2 from './yyy'\n    // 默认导出插件\n    export default {\n        install: function(Vue) {\n            console.log('自定义的插件~')\n            // 在自定义的插件中注册为全局组件\n            Vue.component('组件名1',xxx)\n            Vue.component('组件名2',yyy)\n            // 也可以往Vue的原型对象上添加属性或者方法，名字可以自定义\n            // 在其他.vue结尾的文件中，可以通过this，访问自己添加的属性和方法\n            Vue.prototype.num = 10\n            Vue.prototype.$sayHi = () => {\n                alert('Hi~')\n            }\n        }\n    }\n    在main.js文件下，使用该插件。\n    // 导入写好的自定义插件\n    import myCom from '@/components'\n    Vue.use(myCom)\n\n  //获取注册的组件 (始终返回构造器)\n  var oneComponent=Vue.component('component-one');\n  console.log(oneComponent===Profile)//true,返回的Profile构造器\n\n")])])]),e("h2",{attrs:{id:"_3-mixins"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-mixins"}},[n._v("#")]),n._v(" 3.mixins")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("场景:有些组件有些重复的 js 逻辑,如校验手机验证码,解析时间等,mixins 就可以实现这种混入\n详见另外一篇文档--详解mixins混入使用\n\n")])])]),e("h2",{attrs:{id:"_4-vue-use"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-use"}},[n._v("#")]),n._v(" 4.Vue.use()")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("\n场景:我们使用 element时会先 import,再 Vue.use()一下,实际上就是注册组件,触发 install 方法;\n这个在组件调用会经常使用到;\n会自动组织多次注册相同的插件.\nVue.use()多次调用需写多次\n    Vue.use(myPlugin)\n    Vue.use(Vant)\n    Vue.use(Lazyload)\n")])])]),e("h2",{attrs:{id:"_5-install"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-install"}},[n._v("#")]),n._v(" 5.install")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("场景:在 Vue.use()说到,执行该方法会触发 install\n\nvue提供install可供我们开发新的插件及全局注册组件等\ninstall方法第一个参数是vue的构造器，第二个参数是可选的选项对象\nexport default {\n\tinstall(Vue,option){\n\t\t组件\n\t\t指令\n\t\t混入\n\t\t挂载vue原型\n\t}\n}\n全局注册组件\nimport PageTools from '@/components/PageTools/pageTools.vue'\nexport default {\n  install(Vue) {\n    // 注册组件  挂载函数  注册过滤器  注册自定义指令\n    Vue.component('PageTools', PageTools)\n   \n    Vue.prototype.$sleep = sleep\n    // 过滤器\n    Vue.filter('relTime', relTime)\n  }\n}\n在main.js中直接用引用并Vue.use进行注册\nimport Component from '@/components'\nVue.use(Component)\n全局自定义指令\nexport default{\n\tinstall(Vue){\n\t\tVue.directive('pre',{\n\t\t\tinserted(button,bind){\n\t\t\t\tbutton.addEventListener('click',()=>{\n\t\t\t\t\tif(!button.disabled){\n\t\t\t\t\t\tbutton.disabled = true;\n\t\t\t\t\t\tsetTimeout(()=>{\n\t\t\t\t\t\t\tbutton.disabled = false\n\t\t\t\t\t\t},1000)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n在main.js跟注册组件一样\nimport pre from '@/aiqi'\nVue.use(pre)\n\nvar MyPlugin = {};\n  MyPlugin.install = function (Vue, options) {\n    // 2. 添加全局资源,第二个参数传一个值默认是update对应的值\n    Vue.directive('click', {\n      bind(el, binding, vnode, oldVnode) {\n        //做绑定的准备工作,添加时间监听\n        console.log('指令my-directive的bind执行啦');\n      },\n      inserted: function(el){\n      //获取绑定的元素\n      console.log('指令my-directive的inserted执行啦');\n      },\n      update: function(){\n      //根据获得的新值执行对应的更新\n      //对于初始值也会调用一次\n      console.log('指令my-directive的update执行啦');\n      },\n      componentUpdated: function(){\n      console.log('指令my-directive的componentUpdated执行啦');\n      },\n      unbind: function(){\n      //做清理操作\n      //比如移除bind时绑定的事件监听器\n      console.log('指令my-directive的unbind执行啦');\n      }\n    })\n\n    // 3. 注入组件\n    Vue.mixin({\n      created: function () {\n        console.log('注入组件的created被调用啦');\n        console.log('options的值为',options)\n      }\n    })\n\n    // 4. 添加实例方法\n    Vue.prototype.$myMethod = function (methodOptions) {\n      console.log('实例方法myMethod被调用啦');\n    }\n  }\n\n  //调用MyPlugin\n  Vue.use(MyPlugin,{someOption: true })\n\n  //3.挂载\n  new Vue({\n    el: '#app'\n  });\n\n\n")])])]),e("h2",{attrs:{id:"_4-extends"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-extends"}},[n._v("#")]),n._v(" 4.extends")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("extends用法和mixins很相似,通过暴露一个extends对象到组件中使用。只不过接收的参数是简单的选项对象或构造函数,所以extends只能单次扩展一个组件\n\n定义的属性覆盖规则和mixins一致\n")])])]),e("p",[n._v("Vue.extend和Vue.component是为了创建构造器和组件; mixins和extends是为了拓展组件; install是开发插件; 总的顺序关系: Vue.extend>Vue.component>extends>mixins> 组件")])])}),[],!1,null,null,null);e.default=s.exports}}]);