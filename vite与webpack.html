<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vite与webpack | 前端笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="前端笔记">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.e0cecbec.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.0947dbc9.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.9d54d2e6.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/23.92f18123.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.9cfc9567.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.3d077320.js"><link rel="prefetch" href="/vuepress-blog/assets/js/12.39f7ba05.js"><link rel="prefetch" href="/vuepress-blog/assets/js/13.bd5ca7c4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.069d974e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.d6d34b6f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.661f4a7c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.0096b720.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.ea7d075a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.dda8cf70.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.bbb6e4a0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.5c7b6bab.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.a58ff1d8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.98a50d67.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.91a3e6c3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.b9d79099.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.c50ef18f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.ecd67280.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.44f0800f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.5393f454.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.c1d65828.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.d1281d8d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.8a00952e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.e5857412.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.cc2a8fd0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.0c7488f5.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.5b7ee302.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.4df98777.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.9072547a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.27723f7b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.c72729ae.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.05568b60.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.22bef9bc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.78ead8bc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.d6a8f93b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.b463d848.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.507f6c29.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.05a73236.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.b423c42f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.3dd4dd00.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.44547aad.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.18c29f84.js"><link rel="prefetch" href="/vuepress-blog/assets/js/7.1f43074c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/8.a3e3bbda.js"><link rel="prefetch" href="/vuepress-blog/assets/js/9.7fbdd959.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.e0cecbec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">前端笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>列表</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-blog/commonJS与es6模块化.html" class="sidebar-link">exports、module.exports和export、export default</a></li><li><a href="/vuepress-blog/eslint使用、报错部分快速修复.html" class="sidebar-link">vue-cli中eslint检验指定文件/夹、报错部分快速修复</a></li><li><a href="/vuepress-blog/git-HEAD-与HEAD-的区别.html" class="sidebar-link">git HEAD~与HEAD^的区别</a></li><li><a href="/vuepress-blog/git-merge-no-ff-与-ff-和-squash的区别.html" class="sidebar-link">git merge --no-ff 与--ff 和--squash的区别</a></li><li><a href="/vuepress-blog/Git凭据管理的三种方式-https.html" class="sidebar-link">Git凭据管理的三种方式(https)</a></li><li><a href="/vuepress-blog/git操作指令.html" class="sidebar-link">git命令总结</a></li><li><a href="/vuepress-blog/JS工具函数.html" class="sidebar-link">JS工具函数</a></li><li><a href="/vuepress-blog/js执行机制.html" class="sidebar-link">js执行机制</a></li><li><a href="/vuepress-blog/nodejs-websocket.html" class="sidebar-link">nodejs-websocket</a></li><li><a href="/vuepress-blog/pinia.html" class="sidebar-link">pinia</a></li><li><a href="/vuepress-blog/Proxy和Object-defineProperty.html" class="sidebar-link">Proxy和Object.defineProperty</a></li><li><a href="/vuepress-blog/react笔记.html" class="sidebar-link">react笔记</a></li><li><a href="/vuepress-blog/router4笔记.html" class="sidebar-link">router4笔记</a></li><li><a href="/vuepress-blog/uniapp笔记.html" class="sidebar-link">uniapp笔记</a></li><li><a href="/vuepress-blog/vite与webpack.html" class="active sidebar-link">vite与webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-blog/vite与webpack.html#webpack问题" class="sidebar-link">webpack问题</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/vite与webpack.html#预构建" class="sidebar-link">预构建</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/vite与webpack.html#esbuild的打包速度为什么快" class="sidebar-link">esbuild的打包速度为什么快</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/vite与webpack.html#为什么说vite快-为什么说vite慢" class="sidebar-link">为什么说vite快？为什么说vite慢？</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/vite与webpack.html#什么是依赖预编译" class="sidebar-link">什么是依赖预编译</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/vite与webpack.html#解决方案" class="sidebar-link">解决方案</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/vite与webpack.html#vite的内部核心流程图" class="sidebar-link">vite的内部核心流程图</a></li></ul></li><li><a href="/vuepress-blog/vue-elementui-表单检验中发送接口进行校验.html" class="sidebar-link">vue+elementui 表单检验中发送接口进行校验</a></li><li><a href="/vuepress-blog/vue3+elementplus+ts+pinia踩坑记录.html" class="sidebar-link">vue3+elementplus+ts+pinia踩坑记录</a></li><li><a href="/vuepress-blog/vue3笔记.html" class="sidebar-link">vue3笔记</a></li><li><a href="/vuepress-blog/vuex.html" class="sidebar-link">vuex</a></li><li><a href="/vuepress-blog/Vue中extend-mixins-extends以及Vue-use的install和Vue-nextTick.html" class="sidebar-link">Vue中extend,mixins,extends以及Vue.use的install和Vue.nextTick</a></li><li><a href="/vuepress-blog/vue响应式原理及收集依赖.html" class="sidebar-link">vue响应式原理、依赖收集</a></li><li><a href="/vuepress-blog/vue对数组的处理.html" class="sidebar-link">vue对数组的处理</a></li><li><a href="/vuepress-blog/vue知识点记录.html" class="sidebar-link">vue知识点记录</a></li><li><a href="/vuepress-blog/vue第三方组件css修改.html" class="sidebar-link">vue第三方组件css修改</a></li><li><a href="/vuepress-blog/vue组件通信.html" class="sidebar-link">vue组件通信</a></li><li><a href="/vuepress-blog/webpack笔记.html" class="sidebar-link">webpack笔记</a></li><li><a href="/vuepress-blog/前端学习资料.html" class="sidebar-link">前端学习资料</a></li><li><a href="/vuepress-blog/前端性能优化面试题.html" class="sidebar-link">前端性能优化面试题总结</a></li><li><a href="/vuepress-blog/前端鉴权cookie、session、token、jwt、单点登录.html" class="sidebar-link">前端鉴权cookie、session、token、jwt、单点登录</a></li><li><a href="/vuepress-blog/单点登录SSO.html" class="sidebar-link">单点登录SSO</a></li><li><a href="/vuepress-blog/原型链.html" class="sidebar-link">原型链</a></li><li><a href="/vuepress-blog/常用的正则表达式大全.html" class="sidebar-link">常用的正则表达式大全</a></li><li><a href="/vuepress-blog/开发中容易遇到的问题.html" class="sidebar-link">开发中容易遇到的问题</a></li><li><a href="/vuepress-blog/数据类型判断.html" class="sidebar-link">数据类型判断</a></li><li><a href="/vuepress-blog/样式清单整理.html" class="sidebar-link">样式清单整理</a></li><li><a href="/vuepress-blog/组件库开发.html" class="sidebar-link">组件库开发</a></li><li><a href="/vuepress-blog/网站、论坛合集.html" class="sidebar-link">网站、论坛合集</a></li><li><a href="/vuepress-blog/虚拟DOM与DIFF算法.html" class="sidebar-link">虚拟DOM与DIFF算法</a></li><li><a href="/vuepress-blog/详解mixins混入使用.html" class="sidebar-link">详解mixins混入使用</a></li><li><a href="/vuepress-blog/金额输入框封装（千分位，禁止中文输入）.html" class="sidebar-link">金额输入框封装（千分位，禁止中文输入）</a></li><li><a href="/vuepress-blog/键盘事件keydown，keypress，keyup.html" class="sidebar-link">键盘事件keydown，keypress，keyup</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vite与webpack"><a href="#vite与webpack" class="header-anchor">#</a> vite与webpack</h1> <h2 id="webpack问题"><a href="#webpack问题" class="header-anchor">#</a> webpack问题</h2> <p>公司的项目基本都是基于webpack构建，而我们都会对webpack构建项目进行一些构建速度上的优化，比如缓存等，但是开了缓存之后，开发环境还是会存在慢的问题，主要有两方面</p> <blockquote><ul><li>首次启动慢</li> <li>HMR慢</li></ul></blockquote> <p>首次启动慢的原因是因为webpack是一种bundler方案，需要根据entry找到所有依赖模版，并输出最终的bundle.js；</p> <p>hmr慢是因为babel-loader做语法转换耗时过长,且需要重新生产bundle.js</p> <p>所以针对上面的问题，首先我们可能会想到怎么降低语法转化时间，比如使用esbuild-loader来替换babel-loader，但是这只能减少部分语法转换时间，还是不能解决首次启动慢的问题，所以要从根本上解决开发环境首次启动慢的问题还得换一种思路，也就是现在vite提供的bundless思路，启动的时候，只进行预构建第三方依赖，实际浏览器访问的时候，在通过本地服务器实时转换每个请求的文件，达到缩短首次启动时间的目的</p> <h2 id="预构建"><a href="#预构建" class="header-anchor">#</a> 预构建</h2> <p>做了什么：</p> <ul><li>扫描入口文件，然后通过这些入口，扫描所有用到的依赖</li> <li>将多个依赖进行打包</li> <li>修改这些模块的引入路径 ↓</li></ul> <div class="language- extra-class"><pre class="language-text"><code>- import { createApp, defineCustomElement } from 'vue'
+ import { createApp, defineCustomElement } from '/node_modules/.vite/deps/vue.js?v=b92a21b7'
</code></pre></div><p>node_module 下会多了一个 <code>.vite</code> 文件，依赖预构建的产物会放在 <code>deps</code> 目录下</p> <p>由于 import vue 这种模块引入方式，使用的是 Nodejs 特有的模块查找算法（到 node_modules 中取查找），浏览器无法使用，因此 Vite 会将 <code>vue</code> 替换成一个另一个路径，当浏览器解析到这行 import 语句时，会发送一个 <code>/node_modules/.vite/deps/vue.js?v=b92a21b7</code>， Vite Server 会到该目录下，拿到 vue 预构建之后的产物代码。</p> <h3 id="为什么要预构建"><a href="#为什么要预构建" class="header-anchor">#</a> 为什么要预构建</h3> <blockquote><p><strong>CommonJS 和 UMD 兼容性:</strong> 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。</p> <p><strong>性能：</strong> Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能</p></blockquote> <p>一些包将它们的 ES 模块构建作为许多单独的文件相互导入。例如，<a href="https://unpkg.com/browse/lodash-es/" target="_blank" rel="noopener noreferrer"><code>lodash-es</code> 有超过 600 个内置模块<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>！当我们执行 <code>import { debounce } from 'lodash-es'</code> 时，浏览器同时发出 600 多个 HTTP 请求！尽管服务器在处理这些请求时没有问题，但大量的请求会在浏览器端造成网络拥塞，导致页面的加载速度相当慢。</p> <p>通过预构建 <code>lodash-es</code> 成为一个模块，我们就只需要一个 HTTP 请求了！</p> <h2 id="esbuild的打包速度为什么快"><a href="#esbuild的打包速度为什么快" class="header-anchor">#</a> esbuild的打包速度为什么快</h2> <h3 id="语言优势"><a href="#语言优势" class="header-anchor">#</a> 语言优势</h3> <p>webpack基于js实现，esbuild基于go语言实现。</p> <p>js作为一门解释型语言，程序每次执行都需要先由解释器一边将源码翻译成机器语言，一边调度执行；而go是一种编译型语言，在编译阶段就已经将源码转为机器码，启动时只需要直接执行这些机器码即可。相当于，当esbuild解析我们的js代码文件时，node可能正忙于解析我们打包工具webpack的js代码。</p> <h3 id="多线程优势"><a href="#多线程优势" class="header-anchor">#</a> 多线程优势</h3> <p>go语言具有多线程运行能力，而js本质是一门单线程语言，虽然引入了WebWorker规范后，我们可以使用js在浏览器、Node中实现多线程操作，但是在查阅资料后webpack中并未使用webworker提供的多线程能力。反观esbuild，尽可能饱和地使用各个CPU核，特别是打包过程的解析、代码生成阶段的过程。</p> <h3 id="与ts-loader以及babel-loader对比"><a href="#与ts-loader以及babel-loader对比" class="header-anchor">#</a> 与ts-loader以及babel-loader对比</h3> <h5 id="ts-loader"><a href="#ts-loader" class="header-anchor">#</a> ts-loader</h5> <p>webpack的ts加载器，将ts编译成js。ts-loader在内部是调用了ts的官方编译器--tsc，所以ts-loader和tsc是共享tsconfig.json文件的</p> <p>为了性能的提升，我们一般会设置transpileOnly: true，只做语言的转换，而不做类型检查。esbuild同样完全抛弃了ts的类型检查，只做代码转换。</p> <h5 id="babel-loader-搬运官网"><a href="#babel-loader-搬运官网" class="header-anchor">#</a> babel-loader（搬运官网）</h5> <p>在webpack中使用其将es6+高版本js代码转译为es5低版本，此过程可能需要经过多次数据转换：</p> <ul><li>Webpack 读入源码，此时为字符串形式</li> <li>Babel 解析源码，转换为 AST 形式</li> <li>Babel 将源码 AST 转换为低版本 AST</li> <li>Babel 将低版本 AST generate 为低版本源码，字符串形式</li> <li>Webpack 解析低版本源码</li> <li>Webpack 将多个模块打包成最终产物</li></ul> <p>源码需要经历 <code>string =&gt; AST =&gt; AST =&gt; string =&gt; AST =&gt; string</code> ，在字符串与 AST 之间反复横跳。</p> <p>esbuild最大的不同就是能够在多个编译阶段共用相似的AST结构，尽可能减少字符串到AST的结构转换</p> <h3 id="esbuild-的缺点"><a href="#esbuild-的缺点" class="header-anchor">#</a> esbuild 的缺点</h3> <p>esbuild 只能将代码转成 es6。</p> <p>为了保证 esbuild 的编译效率，esbuild 没有提供 AST 的操作能力。所以一些通过 AST 处理代码的 babel-plugin 没有很好的方法过渡到 esbuild 中（如babel-plugin-import）。so，如果你的项目使用了 babel-plugin-import, 或者一些自定义的 babel-plugin 。在目前来看是没有很好的迁移方案的。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ol><li>js是单线程串行，esbuild是新开一个进程，然后多线程并行，充分发挥多核优势</li> <li>go是纯机器码，肯定要比JIT(即时编译)快</li> <li>不使用 AST，优化了构建流程。</li></ol> <h2 id="为什么说vite快-为什么说vite慢"><a href="#为什么说vite快-为什么说vite慢" class="header-anchor">#</a> 为什么说vite快？为什么说vite慢？</h2> <p>vite项目的启动确实比webpack快，但如果某个界面是首次进入，且依赖比较多/比较复杂的话，那就会比较慢了</p> <p>vite的快：命令行启动快，vite启动时并不会像webpack一样对所有代码进行编译/打包/压缩。官网的说法是，vite通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间，以 原生 ESM 方式提供源码，让浏览器接管了打包程序的部分工作，只需要在浏览器请求源码时进行转换并按需提供源码（运行时进行依赖分析，动态打包，动态引入）。而webpack需要在内存中编译、打包、压缩。（<code>这里的启动是指命令行启动完毕，不是指启动完之后首页加载完毕</code>）</p> <p>vite的慢：加载依赖项很多，很复杂的页面时，页面打开慢。需要一次性请求太多的资源，而且这些资源有些并不是浏览器可以直接运行的，vite还需要动态的解析（<strong>一系列的动态分析/动态资源引入/动态编译</strong>），然后一些需要打包再返回给浏览器。</p> <p>vite启动快的原理，也导致了他在加载依赖项很多，很复杂的页面时，页面打开慢。因为他要进行<strong>一系列的动态分析/动态资源引入/动态编译</strong>。</p> <p>总结：</p> <ul><li>启动的时候只做第三方模块的预构建，且使用esbuild来进行预构建，速度是毫秒级</li> <li>访问页面的时候，在处理路由对应的模块，同样使用esbuild来做转换，所以速度还是非常快</li></ul> <h2 id="什么是依赖预编译"><a href="#什么是依赖预编译" class="header-anchor">#</a> 什么是依赖预编译</h2> <p>会<strong>在 DevServer 启动前</strong>对需要预编译的依赖进行编译，然后在分析模块的导入（import）时会动态地<strong>应用编译过的依赖</strong>。</p> <ul><li>默认情况下，Vite 会将 package.json 中生产依赖 <code>dependencies</code> 的部分启用依赖预编译，即会先对该依赖进行编译，然后将编译后的文件缓存在内存中（node_modules/.vite 文件下），在启动 DevServer 时直接请求该缓存内容。</li> <li>在 vite.config.js 文件中配置 <code>optimizeDeps</code> 选项可以选择<strong>需要或不需要</strong>进行预编译的依赖的名称，Vite 则会根据该选项来确定是否对该依赖进行预编译。</li> <li>在启动时添加 <code>--force</code> options，可以用来<strong>强制重新</strong>进行依赖预编译。</li></ul> <h2 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h2> <p>通过添加类似如下的配置，让vite在启动之初就对某些资源进行预打包，尽量避免后续的动态打包，示例配置如下
<code>vite.config.ts</code></p> <div class="language- extra-class"><pre class="language-text"><code>{
   optimizeDeps: {
      include: [
        'vue',
        'map-factory',
        'element-plus/es',
        'element-plus/es/components/form/style/index',
        'element-plus/es/components/radio-group/style/index',
        'element-plus/es/components/radio/style/index',
        'element-plus/es/components/checkbox/style/index',
        'element-plus/es/components/checkbox-group/style/index',
        'element-plus/es/components/switch/style/index',
        'element-plus/es/components/time-picker/style/index',
        'element-plus/es/components/date-picker/style/index',
        'element-plus/es/components/col/style/index',
        'element-plus/es/components/form-item/style/index',
        'element-plus/es/components/alert/style/index',
        'element-plus/es/components/breadcrumb/style/index',
        'element-plus/es/components/select/style/index',
        'element-plus/es/components/input/style/index',
        'element-plus/es/components/breadcrumb-item/style/index',
        'element-plus/es/components/tag/style/index',
        'element-plus/es/components/pagination/style/index',
        'element-plus/es/components/table/style/index',
        'element-plus/es/components/table-column/style/index',
        'element-plus/es/components/card/style/index',
        'element-plus/es/components/row/style/index',
        'element-plus/es/components/button/style/index',
        'element-plus/es/components/menu/style/index',
        'element-plus/es/components/sub-menu/style/index',
        'element-plus/es/components/menu-item/style/index',
        'element-plus/es/components/option/style/index',
        '@element-plus/icons-vue',
        'pinia',
        'axios',
        'vue-request',
        'vue-router',
        '@vueuse/core',
      ],
    }
}

</code></pre></div><h3 id="插件vite-plugin-optimize-persist"><a href="#插件vite-plugin-optimize-persist" class="header-anchor">#</a> 插件<a href="https://www.npmjs.com/package/vite-plugin-optimize-persist" target="_blank" rel="noopener noreferrer">vite-plugin-optimize-persist<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <div class="language- extra-class"><pre class="language-text"><code>npm i -D vite-plugin-optimize-persist vite-plugin-package-config
</code></pre></div><p><code>vite.config.ts</code> 中增加配置</p> <div class="language- extra-class"><pre class="language-text"><code>// vite.config.ts
import OptimizationPersist from 'vite-plugin-optimize-persist'
import PkgConfig from 'vite-plugin-package-config'

export default {
  plugins: [
    PkgConfig(),
    OptimizationPersist()
  ]
}
</code></pre></div><p>首次加载的时候，依然会很慢，这个是正常现象，因为这个插件, 加快vite载入界面速度的原理, 也和上面说的一样，而第一次，这个插件也没法知道，哪些依赖需要预构建，他只是在vite动态引入资源的时候，将这些资源都记录下来，自动写入了package.json中，当再次启动项目的时候，插件会读取之前他写入在package.json中的数据，并告知vite，这样vite就能对这些资源进行预构建了，也就能加快进入界面的速度了，但相应的启动速度就会比原来稍微慢一点</p> <h2 id="vite的内部核心流程图"><a href="#vite的内部核心流程图" class="header-anchor">#</a> vite的内部核心流程图</h2> <p><img src="https://fengqichang666.github.io/images/vite2build.png" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress-blog/uniapp笔记.html" class="prev">
        uniapp笔记
      </a></span> <span class="next"><a href="/vuepress-blog/vue-elementui-表单检验中发送接口进行校验.html">
        vue+elementui 表单检验中发送接口进行校验
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><section class="side-anchor"><ul style="display:none;"></ul></section></div></div>
    <script src="/vuepress-blog/assets/js/app.0947dbc9.js" defer></script><script src="/vuepress-blog/assets/js/2.9d54d2e6.js" defer></script><script src="/vuepress-blog/assets/js/23.92f18123.js" defer></script>
  </body>
</html>
