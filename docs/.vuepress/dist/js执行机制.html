<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js执行机制 | 前端笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="前端笔记">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.a40a9d3e.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.ae308451.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.9d54d2e6.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/17.7fa352c1.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.9cfc9567.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.3d077320.js"><link rel="prefetch" href="/vuepress-blog/assets/js/12.555fb7d9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/13.7bfdc094.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.04b16a6e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.a4e3bda4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.4d164b2f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.0a23db7e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.dda8cf70.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.54572099.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.37f1d204.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.dbccb16a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.43a77620.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.fc4eb2fe.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.91a3e6c3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.fcd26691.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.a339bfc4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.5ebd68a8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.44f0800f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.446fcee1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.c1d65828.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.5e6969f9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.e47746a1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.a737a274.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.1bf44f55.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.ba7921cb.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.49fdf229.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.d72b0415.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.9072547a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.27723f7b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.c72729ae.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.2e56f701.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.ce193a1e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.78ead8bc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.8212ce5d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.0129c968.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.507f6c29.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.256af657.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.b423c42f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.3dd4dd00.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.698d18d8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.18c29f84.js"><link rel="prefetch" href="/vuepress-blog/assets/js/7.1f43074c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/8.a3e3bbda.js"><link rel="prefetch" href="/vuepress-blog/assets/js/9.43e7f945.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.a40a9d3e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">前端笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>列表</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-blog/commonJS与es6模块化.html" class="sidebar-link">exports、module.exports和export、export default</a></li><li><a href="/vuepress-blog/eslint使用、报错部分快速修复.html" class="sidebar-link">vue-cli中eslint检验指定文件/夹、报错部分快速修复</a></li><li><a href="/vuepress-blog/git-HEAD-与HEAD-的区别.html" class="sidebar-link">git HEAD~与HEAD^的区别</a></li><li><a href="/vuepress-blog/git-merge-no-ff-与-ff-和-squash的区别.html" class="sidebar-link">git merge --no-ff 与--ff 和--squash的区别</a></li><li><a href="/vuepress-blog/Git凭据管理的三种方式-https.html" class="sidebar-link">Git凭据管理的三种方式(https)</a></li><li><a href="/vuepress-blog/git操作指令.html" class="sidebar-link">git命令总结</a></li><li><a href="/vuepress-blog/JS工具函数.html" class="sidebar-link">JS工具函数</a></li><li><a href="/vuepress-blog/js执行机制.html" class="active sidebar-link">js执行机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-blog/js执行机制.html#heap-堆" class="sidebar-link">Heap(堆)</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/js执行机制.html#栈-stack" class="sidebar-link">栈（Stack）</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/js执行机制.html#队列-queue" class="sidebar-link">队列（Queue）</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/js执行机制.html#event-loop-事件循环" class="sidebar-link">Event Loop(事件循环)</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/js执行机制.html#js执行机制" class="sidebar-link">JS执行机制</a></li></ul></li><li><a href="/vuepress-blog/nodejs-websocket.html" class="sidebar-link">nodejs-websocket</a></li><li><a href="/vuepress-blog/pinia.html" class="sidebar-link">pinia</a></li><li><a href="/vuepress-blog/Proxy和Object-defineProperty.html" class="sidebar-link">Proxy和Object.defineProperty</a></li><li><a href="/vuepress-blog/react笔记.html" class="sidebar-link">react笔记</a></li><li><a href="/vuepress-blog/router4笔记.html" class="sidebar-link">router4笔记</a></li><li><a href="/vuepress-blog/uniapp笔记.html" class="sidebar-link">uniapp笔记</a></li><li><a href="/vuepress-blog/vite与webpack.html" class="sidebar-link">vite与webpack</a></li><li><a href="/vuepress-blog/vue-elementui-表单检验中发送接口进行校验.html" class="sidebar-link">vue+elementui 表单检验中发送接口进行校验</a></li><li><a href="/vuepress-blog/vue3+elementplus+ts+pinia踩坑记录.html" class="sidebar-link">vue3+elementplus+ts+pinia踩坑记录</a></li><li><a href="/vuepress-blog/vue3笔记.html" class="sidebar-link">vue3笔记</a></li><li><a href="/vuepress-blog/vuex.html" class="sidebar-link">vuex</a></li><li><a href="/vuepress-blog/Vue中extend-mixins-extends以及Vue-use的install和Vue-nextTick.html" class="sidebar-link">Vue中extend,mixins,extends以及Vue.use的install和Vue.nextTick</a></li><li><a href="/vuepress-blog/vue响应式原理及收集依赖.html" class="sidebar-link">vue响应式原理、依赖收集</a></li><li><a href="/vuepress-blog/vue对数组的处理.html" class="sidebar-link">vue对数组的处理</a></li><li><a href="/vuepress-blog/vue知识点记录.html" class="sidebar-link">vue知识点记录</a></li><li><a href="/vuepress-blog/vue第三方组件css修改.html" class="sidebar-link">vue第三方组件css修改</a></li><li><a href="/vuepress-blog/vue组件通信.html" class="sidebar-link">vue组件通信</a></li><li><a href="/vuepress-blog/webpack笔记.html" class="sidebar-link">webpack笔记</a></li><li><a href="/vuepress-blog/前端学习资料.html" class="sidebar-link">前端学习资料</a></li><li><a href="/vuepress-blog/前端性能优化面试题.html" class="sidebar-link">前端性能优化面试题总结</a></li><li><a href="/vuepress-blog/前端鉴权cookie、session、token、jwt、单点登录.html" class="sidebar-link">前端鉴权cookie、session、token、jwt、单点登录</a></li><li><a href="/vuepress-blog/单点登录SSO.html" class="sidebar-link">单点登录SSO</a></li><li><a href="/vuepress-blog/原型链.html" class="sidebar-link">原型链</a></li><li><a href="/vuepress-blog/常用的正则表达式大全.html" class="sidebar-link">常用的正则表达式大全</a></li><li><a href="/vuepress-blog/开发中容易遇到的问题.html" class="sidebar-link">开发中容易遇到的问题</a></li><li><a href="/vuepress-blog/数据类型判断.html" class="sidebar-link">数据类型判断</a></li><li><a href="/vuepress-blog/样式清单整理.html" class="sidebar-link">样式清单整理</a></li><li><a href="/vuepress-blog/组件库开发.html" class="sidebar-link">组件库开发</a></li><li><a href="/vuepress-blog/网站、论坛合集.html" class="sidebar-link">网站、论坛合集</a></li><li><a href="/vuepress-blog/虚拟DOM与DIFF算法.html" class="sidebar-link">虚拟DOM与DIFF算法</a></li><li><a href="/vuepress-blog/详解mixins混入使用.html" class="sidebar-link">详解mixins混入使用</a></li><li><a href="/vuepress-blog/金额输入框封装（千分位，禁止中文输入）.html" class="sidebar-link">金额输入框封装（千分位，禁止中文输入）</a></li><li><a href="/vuepress-blog/键盘事件keydown，keypress，keyup.html" class="sidebar-link">键盘事件keydown，keypress，keyup</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><img src="https://fengqichang666.github.io/images/20200618180003244.png" alt="js执行机制"></p> <h1 id="heap-堆-、stack-栈-、queue-队列-、event-loop-事件循环"><a href="#heap-堆-、stack-栈-、queue-队列-、event-loop-事件循环" class="header-anchor">#</a> Heap(堆)、Stack(栈)、Queue(队列)、Event Loop(事件循环)</h1> <h2 id="heap-堆"><a href="#heap-堆" class="header-anchor">#</a> <strong>Heap(堆)</strong></h2> <p>堆是<strong>线性数据结构</strong>，相当于<strong>一维数组</strong>，有唯一后继。</p> <p>动态分配的内存，大小不定也不会自动释放，存放<strong>引用类型</strong>，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，<strong>实际上保存的不是变量本身，而是指向该对象的指针</strong>。</p> <p><strong>堆的作用</strong>：存储引用类型值的数据</p> <p><strong>堆内存的释放</strong>    让所有引用堆内存空间地址的变量赋值为 null 即可，当堆内存没有被任何的变量或者其他东西引用时，就会在浏览器执行垃圾回收的时候，被销毁掉。</p> <h2 id="栈-stack"><a href="#栈-stack" class="header-anchor">#</a> <strong>栈（Stack）</strong></h2> <p>栈在程序中的设定是限定仅在表尾进行插入或删除操作的线性表。栈是一种数据结构，它按照<strong>后进先出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶</p> <p>js中的栈准确来将应该叫调用栈，会自动分配内存空间，会自动释放，存放<strong>基本类型</strong>，简单的数据段，占据固定大小的空间。</p> <p><strong>栈的作用</strong>：存储基本类型值，还有一个很要的作用。<strong>提供代码执行的环境</strong>（提供一个供 JS 代码自上而下执行的环境（作用域，代码都是在栈内存中执行的）</p> <p><strong>栈内存的释放</strong>    全局作用域会在页面关闭或者刷新的时候释放。（栈内存释放后，存储在栈内存中的值也都会销毁。)</p> <h2 id="队列-queue"><a href="#队列-queue" class="header-anchor">#</a> <strong>队列（Queue</strong>）</h2> <p>和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列中没有元素时，称为<strong>空队列</strong>。</p> <p>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为<strong>先进先出</strong></p> <h4 id="js中的队列"><a href="#js中的队列" class="header-anchor">#</a> js中的队列</h4> <p>所有的同步任务都是在主进程执行的形成一个执行栈，主线程之外，还存在一个<strong>任务队列</strong>，任务队列里存放的任务分为两种任务类型，宏任务(<code>macroTask</code>)和微任务(<code>microTask</code>)。异步任务执行队列中先执行宏任务，然后清空当次宏任务中的所有微任务，然后进行下一个tick如此形成循环。</p> <h2 id="event-loop-事件循环"><a href="#event-loop-事件循环" class="header-anchor">#</a> Event Loop(事件循环)</h2> <p>JS是一门单线程的非阻塞脚本语言，Event Loop就是为了解决JS异步编程的一种解决方案。</p> <p>所谓单线程，就是指一次只能完成一件任务，如果在同个时间有多个任务的话，这些任务就需要进行排队，前一个任务执行完，才会执行下一个任务。但如果有一个任务的执行时间很长，比如文件的读取或者数据的请求等等，那么后面的任务就要一直等待，这就会影响用户的使用体验。
为了解决这种情况，Javascript语言将任务的执行模式分成两种：<strong>同步</strong>（Synchronous）和<strong>异步</strong>（Asynchronous）。</p> <h3 id="同步任务"><a href="#同步任务" class="header-anchor">#</a> 同步任务</h3> <p>代码从上到下按顺序执行</p> <p>同步模式就是前一个任务执行完成后，再执行下一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的；</p> <h3 id="异步任务"><a href="#异步任务" class="header-anchor">#</a> 异步任务</h3> <p>异步任务分为宏任务、微任务。每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行队列上的后一个任务，而是执行回调函数；后一个任务则是不等前一个任务的回调函数的执行而执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p> <h4 id="macrotack-宏任务"><a href="#macrotack-宏任务" class="header-anchor">#</a> Macrotack（宏任务）：</h4> <p>script(整体代码)、setTimeout、setInterval、setImmediateI/O、UI交互事件、postMessage、MessageChannel</p> <h4 id="microtack-微任务"><a href="#microtack-微任务" class="header-anchor">#</a> Microtack（微任务）:</h4> <p>Promise.then、MutationObserver、process.nextTick(Node环境)</p> <h3 id="event-loop"><a href="#event-loop" class="header-anchor">#</a> Event Loop</h3> <p>JS 在解析一段代码时，会将同步代码按顺序排在某个地方，即执行栈，然后依次执行里面的函数。当遇到异步任务时就交给其他线程(执行队列)处理，待当前执行栈所有同步代码执行完成后，会从一个队列中去取出已完成的异步任务(<strong>宏任务和微任务，在异步中微任务是优于宏任务执行的</strong>）的回调加入执行栈继续执行，遇到异步任务时又交给其他线程，.....，如此循环往复。而其他异步任务完成后，将回调放入任务队列中待执行栈来取出执行。</p> <p>· 如此循环，就形成js的事件循环机制（Event Loop）</p> <h3 id="js为什么是单线程语言-那它是怎么实现异步编程-非阻塞-运行的"><a href="#js为什么是单线程语言-那它是怎么实现异步编程-非阻塞-运行的" class="header-anchor">#</a> JS为什么是单线程语言，那它是怎么实现异步编程(非阻塞)运行的</h3> <p>1、JavaScript的诞生就是为了处理浏览器网页的交互（DOM操作的处理、UI动画等),  设计成单线程的原因就是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果（两个线程修改了同一个DOM节点就会产生不必要的麻烦），这对于一种网页脚本语言来说这就太复杂了。</p> <p>2、JavaScript是单线程的但它所运行的宿主环境—浏览器是多线程，浏览器提供了各种线程供Event Loop调度来协调JS单线程运行时不会阻塞。</p> <h2 id="js执行机制"><a href="#js执行机制" class="header-anchor">#</a> <strong>JS执行机制</strong></h2> <p><strong>主线程（宏任务） =&gt; 微任务 =&gt; 宏任务 =&gt; 主线程</strong></p> <p>如果宏任务里还有微任就继续执行宏任务里的微任务，如果宏任务中的微任务中还有宏任务就在依次进行</p> <p><strong>主线程任务——&gt;微任务——&gt;宏任务——&gt;宏任务里的微任务——&gt;宏任务里的微任务中的宏任务——&gt;直到任务全部完成</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress-blog/JS工具函数.html" class="prev">
        JS工具函数
      </a></span> <span class="next"><a href="/vuepress-blog/nodejs-websocket.html">
        nodejs-websocket
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><section class="side-anchor"><ul style="display:none;"></ul></section></div></div>
    <script src="/vuepress-blog/assets/js/app.ae308451.js" defer></script><script src="/vuepress-blog/assets/js/2.9d54d2e6.js" defer></script><script src="/vuepress-blog/assets/js/17.7fa352c1.js" defer></script>
  </body>
</html>
