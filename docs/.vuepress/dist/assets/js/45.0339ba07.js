(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{318:function(e,n,t){"use strict";t.r(n);var d=t(14),o=Object(d.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"虚拟dom-virtual-dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom-virtual-dom"}},[e._v("#")]),e._v(" 虚拟DOM(Virtual DOM)")]),e._v(" "),n("h3",{attrs:{id:"什么是虚拟dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟dom"}},[e._v("#")]),e._v(" 什么是虚拟DOM")]),e._v(" "),n("p",[e._v("一句话总结虚拟DOM就是一个用来描述真实DOM的**javaScript对象 ** 包含tag，props，children三个属性。。。")]),e._v(" "),n("p",[n("code",[e._v("真实DOM")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<ul class="list">\n    <li>a</li>\n    <li>b</li>\n    <li>c</li>\n</ul>\n')])])]),n("p",[n("code",[e._v("对应的虚拟DOM")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let vnode = h('ul.list', [\n  h('li','a'),\n  h('li','b'),\n  h('li','c'),\n])\n\nconsole.log(vnode)\n")])])]),n("h4",{attrs:{id:"控制台打印出来的vnode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#控制台打印出来的vnode"}},[e._v("#")]),e._v(" 控制台打印出来的"),n("strong",[e._v("Vnode")]),e._v(":")]),e._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://fengqichang666.github.io/images/640.webp"}}),e._v(" "),n("p",[n("strong",[e._v("h函数就是vue中的createElement方法，这个函数作用就是创建虚拟dom，追踪dom变化的")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function h(tag,props,...children){//h函数，返回一个虚拟dom对象\n    return {\n        tag,\n        props:props || {},\n        children:children.flat()//扁平化数组，降至一维数组\n    }\n}\n//源码\nexport function h (sel: string): VNode\nexport function h (sel: string, data: VNodeData | null): VNode\nexport function h (sel: string, children: VNodeChildren): VNode\nexport function h (sel: string, data: VNodeData | null, children: VNodeChildren): VNode\nexport function h (sel: any, b?: any, c?: any): VNode {\n  var data: VNodeData = {}\n  var children: any\n  var text: any\n  var i: number\n    ...\n  return vnode(sel, data, children, text, undefined) //最终返回一个vnode函数\n};\n// vnode函数\nexport function vnode (sel: string | undefined,\n  data: any | undefined,\n  children: Array<VNode | string> | undefined,\n  text: string | undefined,\n  elm: Element | Text | undefined): VNode {\n  const key = data === undefined ? undefined : data.key\n  return { sel, data, children, text, elm, key } //最终生成Vnode对象\n}\n")])])]),n("p",[n("code",[e._v("h函数")]),e._v("先生成一个"),n("code",[e._v("vnode")]),e._v("函数,然后"),n("code",[e._v("vnode")]),e._v("函数再生成一个"),n("code",[e._v("Vnode")]),e._v("对象(虚拟DOM对象)")]),e._v(" "),n("p",[n("strong",[e._v("最终html代码会被编译成h函数的渲染形式。返回的是一个虚拟DOM对象，通过diff算法，来追踪自己要如何改变真实DOM。")])]),e._v(" "),n("p",[e._v("createElment参数（也就是h函数）：createElment函数接受三个参数，分别是：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" 参数一：tag（标签名）、组件的选项对象、函数（必选）；\n\n 参数二：一个对象，标签的属性对应的数据（可选）；\n\n 参数三：子级虚拟节点，字符串形式或数组形式，子级虚拟节点也需要使用createElement构建。\n")])])]),n("h3",{attrs:{id:"为什么要使用虚拟dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用虚拟dom"}},[e._v("#")]),e._v(" 为什么要使用虚拟DOM")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("MVVM框架解决视图和状态同步问题")])]),e._v(" "),n("li",[n("p",[e._v("模板引擎可以简化视图操作,没办法跟踪状态")])]),e._v(" "),n("li",[n("p",[e._v("虚拟DOM跟踪状态变化")])]),e._v(" "),n("li",[n("p",[e._v("参考github上"),n("strong",[e._v("virtual-dom")]),e._v("[1]的动机描述")])]),e._v(" "),n("li",[n("ul",[n("li",[e._v("虚拟DOM可以维护程序的状态,跟踪上一次的状态")]),e._v(" "),n("li",[e._v("通过比较前后两次状态差异更新真实DOM")])])]),e._v(" "),n("li",[n("p",[e._v("跨平台使用")])]),e._v(" "),n("li",[n("ul",[n("li",[e._v("浏览器平台渲染DOM")]),e._v(" "),n("li",[e._v("服务端渲染SSR(Nuxt.js/Next.js),前端是vue向,后者是react向")]),e._v(" "),n("li",[e._v("原生应用(Weex/React Native)")]),e._v(" "),n("li",[e._v("小程序(mpvue/uni-app)等")])])]),e._v(" "),n("li",[n("p",[e._v("真实DOM的属性很多，创建DOM节点开销很大")])]),e._v(" "),n("li",[n("p",[e._v("虚拟DOM只是普通JavaScript对象，描述属性并不需要很多，创建开销很小")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("复杂视图情况下提升渲染性能")]),e._v("(操作dom性能消耗大,减少操作dom的范围可以提升性能)")])])]),e._v(" "),n("p",[n("strong",[e._v("复杂视图情况下提升渲染性能")]),e._v(",因为"),n("code",[e._v("虚拟DOM+Diff算法")]),e._v("可以精准找到DOM树变更的地方,减少DOM的操作(重排重绘)")]),e._v(" "),n("h2",{attrs:{id:"diff算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[e._v("#")]),e._v(" Diff算法")]),e._v(" "),n("p",[e._v("diff 算法首先要明确一个概念就是 Diff 的对象是虚拟DOM（virtual dom），更新真实 DOM 是 Diff 算法的结果。")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("init()")]),e._v("设置模块.创建"),n("code",[e._v("patch()")]),e._v("函数")]),e._v(" "),n("li",[e._v("使用"),n("code",[e._v("h()")]),e._v("函数创建JavaScript对象"),n("code",[e._v("(Vnode)")]),e._v("描述"),n("code",[e._v("真实DOM")])]),e._v(" "),n("li",[n("code",[e._v("patch()")]),e._v("比较"),n("code",[e._v("新旧两个Vnode")])]),e._v(" "),n("li",[e._v("把变化的内容更新到"),n("code",[e._v("真实DOM树")])])]),e._v(" "),n("h3",{attrs:{id:"init函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#init函数"}},[e._v("#")]),e._v(" init函数")]),e._v(" "),n("p",[e._v("init函数时设置模块,然后创建patch()函数,我们先通过场景案例来有一个直观的体现:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import {init} from 'snabbdom/build/package/init.js'\nimport {h} from 'snabbdom/build/package/h.js'\n\n// 1.导入模块\nimport {styleModule} from \"snabbdom/build/package/modules/style\";\nimport {eventListenersModule} from \"snabbdom/build/package/modules/eventListeners\";\n\n// 2.注册模块\nconst patch = init([\n  styleModule,\n  eventListenersModule\n])\n\n// 3.使用h()函数的第二个参数传入模块中使用的数据(对象)\nlet vnode = h('div', [\n  h('h1', {style: {backgroundColor: 'red'}}, 'Hello world'),\n  h('p', {on: {click: eventHandler}}, 'Hello P')\n])\n\nfunction eventHandler() {\n  alert('疼,别摸我')\n}\n\nconst app = document.querySelector('#app')\n\npatch(app,vnode)\n")])])]),n("p",[e._v("当init使用了导入的模块就能够在h函数中用这些模块提供的api去创建"),n("code",[e._v("虚拟DOM(Vnode)对象")]),e._v(";在上文中就使用了"),n("code",[e._v("样式模块")]),e._v("以及"),n("code",[e._v("事件模块")]),e._v("让创建的这个虚拟DOM具备样式属性以及事件属性,最终通过"),n("code",[e._v("patch函数")]),e._v("对比"),n("code",[e._v("两个虚拟dom")]),e._v("(会先把app转换成虚拟dom),更新视图;")]),e._v(" "),n("h3",{attrs:{id:"patch函数-核心"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#patch函数-核心"}},[e._v("#")]),e._v(" patch函数(核心)")]),e._v(" "),n("ul",[n("li",[e._v("pactch(oldVnode,newVnode)")]),e._v(" "),n("li",[e._v("把新节点中变化的内容渲染到真实DOM,最后返回新节点作为下一次处理的旧节点(核心)")]),e._v(" "),n("li",[e._v("对比新旧"),n("code",[e._v("VNode")]),e._v("是否相同节点(节点的key和sel相同)")]),e._v(" "),n("li",[e._v("如果不是相同节点,删除之前的内容,重新渲染")]),e._v(" "),n("li",[e._v("如果是相同节点,再判断新的"),n("code",[e._v("VNode")]),e._v("是否有"),n("code",[e._v("text")]),e._v(",如果有并且和"),n("code",[e._v("oldVnode")]),e._v("的"),n("code",[e._v("text")]),e._v("不同直接更新文本内容"),n("code",[e._v("(patchVnode)")])]),e._v(" "),n("li",[e._v("如果新的VNode有children,判断子节点是否有变化"),n("code",[e._v("(updateChildren,最麻烦,最难实现)")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {    \n    let i: number, elm: Node, parent: Node\n    const insertedVnodeQueue: VNodeQueue = []\n    // cbs.pre就是所有模块的pre钩子函数集合\n    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]()\n    // isVnode函数时判断oldVnode是否是一个虚拟DOM对象\n    if (!isVnode(oldVnode)) {\n        // 若不是即把Element转换成一个虚拟DOM对象\n        oldVnode = emptyNodeAt(oldVnode)\n    }\n    // sameVnode函数用于判断两个虚拟DOM是否是相同的,源码见补充1;\n    if (sameVnode(oldVnode, vnode)) {\n        // 相同则运行patchVnode对比两个节点,关于patchVnode后面会重点说明(核心)\n        patchVnode(oldVnode, vnode, insertedVnodeQueue)\n    } else {\n        elm = oldVnode.elm! // !是ts的一种写法代码oldVnode.elm肯定有值\n        // parentNode就是获取父元素\n        parent = api.parentNode(elm) as Node\n\n        // createElm是用于创建一个dom元素插入到vnode中(新的虚拟DOM)\n        createElm(vnode, insertedVnodeQueue)\n\n        if (parent !== null) {\n            // 把dom元素插入到父元素中,并且把旧的dom删除\n            api.insertBefore(parent, vnode.elm!, api.nextSibling(elm))// 把新创建的元素放在旧的dom后面\n            removeVnodes(parent, [oldVnode], 0, 0)\n        }\n    }\n\n    for (i = 0; i < insertedVnodeQueue.length; ++i) {\n        insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i])\n    }\n    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]()\n    return vnode\n}\n")])])]),n("h4",{attrs:{id:"补充1-samevnode函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#补充1-samevnode函数"}},[e._v("#")]),e._v(" 补充1: sameVnode函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function sameVnode(vnode1: VNode, vnode2: VNode): boolean { 通过key和sel选择器判断是否是相同节点\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel\n}\n")])])]),n("h3",{attrs:{id:"patchvnode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#patchvnode"}},[e._v("#")]),e._v(" patchVnode")]),e._v(" "),n("ul",[n("li",[e._v("第一阶段触发"),n("code",[e._v("prepatch")]),e._v("函数以及"),n("code",[e._v("update")]),e._v("函数(都会触发prepatch函数,两者不完全相同才会触发update函数)")]),e._v(" "),n("li",[e._v("第二阶段,真正对比新旧"),n("code",[e._v("vnode")]),e._v("差异的地方")]),e._v(" "),n("li",[e._v("第三阶段,触发"),n("code",[e._v("postpatch")]),e._v("函数更新节点")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) {\n    const hook = vnode.data?.hook\n    hook?.prepatch?.(oldVnode, vnode)\n    const elm = vnode.elm = oldVnode.elm!\n    const oldCh = oldVnode.children as VNode[]\n    const ch = vnode.children as VNode[]\n    if (oldVnode === vnode) return\n    if (vnode.data !== undefined) {\n        for (let i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\n        vnode.data.hook?.update?.(oldVnode, vnode)\n    }\n    if (isUndef(vnode.text)) { // 新节点的text属性是undefined\n        if (isDef(oldCh) && isDef(ch)) { // 当新旧节点都存在子节点\n            if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue) //并且他们的子节点不相同执行updateChildren函数,后续会重点说明(核心)\n        } else if (isDef(ch)) { // 只有新节点有子节点\n            // 当旧节点有text属性就会把''赋予给真实dom的text属性\n            if (isDef(oldVnode.text)) api.setTextContent(elm, '') \n            // 并且把新节点的所有子节点插入到真实dom中\n            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n        } else if (isDef(oldCh)) { // 清除真实dom的所有子节点\n            removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n        } else if (isDef(oldVnode.text)) { // 把''赋予给真实dom的text属性\n            api.setTextContent(elm, '')\n        }\n    } else if (oldVnode.text !== vnode.text) { //若旧节点的text与新节点的text不相同\n        if (isDef(oldCh)) { // 若旧节点有子节点,就把所有的子节点删除\n            removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n        }\n        api.setTextContent(elm, vnode.text!) // 把新节点的text赋予给真实dom\n    }\n    hook?.postpatch?.(oldVnode, vnode) // 更新视图\n}\n")])])]),n("p",[n("img",{attrs:{src:"https://fengqichang666.github.io/images/Diff.webp",alt:""}})]),e._v(" "),n("h3",{attrs:{id:"updatechildren-核中核-判断子节点的差异"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#updatechildren-核中核-判断子节点的差异"}},[e._v("#")]),e._v(" updateChildren(核中核:判断子节点的差异)")]),e._v(" "),n("p",[e._v("这个函数分为三个部分,"),n("code",[e._v("部分1:声明变量")]),e._v(","),n("code",[e._v("部分2:同级别节点比较")]),e._v(","),n("code",[e._v("部分3:循环结束的收尾工作")])]),e._v(" "),n("ul",[n("li",[n("p",[n("code",[e._v("同级别节点比较")]),e._v("的"),n("code",[e._v("五种")]),e._v("情况:")])]),e._v(" "),n("li",[n("ol",[n("li",[n("code",[e._v("oldStartVnode/newStartVnode")]),e._v("(旧开始节点/新开始节点)相同")]),e._v(" "),n("li",[n("code",[e._v("oldEndVnode/newEndVnode")]),e._v("(旧结束节点/新结束节点)相同")]),e._v(" "),n("li",[n("code",[e._v("oldStartVnode/newEndVnode")]),e._v("(旧开始节点/新结束节点)相同")]),e._v(" "),n("li",[n("code",[e._v("oldEndVnode/newStartVnode")]),e._v("(旧结束节点/新开始节点)相同")]),e._v(" "),n("li",[n("code",[e._v("特殊情况当1,2,3,4的情况都不符合")]),e._v("的时候就会执行,在"),n("code",[e._v("oldVnodes")]),e._v("里面寻找跟"),n("code",[e._v("newStartVnode")]),e._v("一样的节点然后位移到"),n("code",[e._v("oldStartVnode")]),e._v(",若没有找到在就"),n("code",[e._v("oldStartVnode")]),e._v("创建一个")])])]),e._v(" "),n("li",[n("p",[e._v("执行过程是一个循环,在每次循环里,只要执行了上述的情况的五种之一就会结束一次循环")])]),e._v(" "),n("li",[n("p",[n("code",[e._v("循环结束的收尾工作")]),e._v(":直到oldStartIdx>oldEndIdx || newStartIdx>newEndIdx(代表旧节点或者新节点已经遍历完)")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);