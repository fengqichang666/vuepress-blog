(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{281:function(e,t,n){"use strict";n.r(t);var s=n(14),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"object-defineproperty"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Object.defineProperty")])]),e._v(" "),t("p",[e._v("vue2.x 以及之前的版本使用 Object.defineProperty 实现数据的双向绑定，简单实现下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let obj = {\n  name: '李四',\n  address: '上海浦东新区',\n  flags: {\n    book: {\n      page: 153,\n      name: 'JS'\n    },\n    hobby: ['足球', '游戏', '音乐']\n  }\n}\nfunction observer(obj) {\n  if (typeof obj == 'object') {\n    for (let key in obj) {\n      defineReactive(obj, key, obj[key])\n    }\n  }\n}\n \nfunction defineReactive(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    get() {\n      console.log('获取：' + key)\n      return value\n    },\n    set(val) {\n      observer(val)\n      console.log(key + \"-数据改变了\")\n      value = val\n    }\n  })\n}\n \nobserver(obj)\n")])])]),t("p",[e._v("问题1.删除或者增加对象属性无法监听到")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Vue.$delete(target,key)   this.$delete(this.form,\'members1\')\n\n方案一：利用Vue.set(object,key,value)\nVue.set(vm.obj,"sex","man")\n\n方案二：利用this.$set(this.object,key,value)\nthis.$set(this.obj,"sex","man")\n\n方案三：利用Object.assign({},this.obj)\nthis.obj.sex = "man";\nthis.obj = Object.assign({},this.obj)\n或者下面方式\nthis.obj = Object.assign({ },this.obj,{"sex","man"})\n')])])]),t("p",[e._v("问题2.数组的变化无法监听到   比如 obj.arr[0]='sss' 打印 ['sss', '游戏', '音乐'] 只会触发get  不会触发set;")]),e._v(" "),t("div",{staticClass:"language-swift extra-class"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[e._v("可以检测到：\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("push")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("pop")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("shift")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("unshift")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("splice")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("sort")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("reverse")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),t("p",[e._v("问题3. 由于是使用递归遍历对象，使用 Object.defineProperty 劫持对象的属性，如果遍历的对象层级比较深，花的时间比较久，甚至有性能的问题")]),e._v(" "),t("h2",{attrs:{id:"proxy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" "),t("strong",[e._v("proxy")])]),e._v(" "),t("p",[e._v("对象用于定义基本操作的自定义行为")]),e._v(" "),t("p",[e._v("简单来说就是，可以在对目标对象设置一层拦截。无论对目标对象进行什么操作，都要经过这层拦截")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let obj = {\n      name: '李四',\n      address: '上海浦东新区',\n      flags: {\n        book: {\n          page: 153,\n          name: 'JS'\n        },\n        hobby: ['足球', '游戏', '音乐']\n      }\n    }\n \n \n    function observerProxy(obj) {\n      const handler = {\n        get(target, key, receiver) {\n          console.log('获取：' + key) // 如果是对象，就递归添加 proxy 拦截\n          if (typeof target[key] === 'object' && target[key] !== null) {\n            return new Proxy(target[key], handler)\n          }\n          return Reflect.get(target, key, receiver)\n        },\n        set(target, key, value, receiver) {\n          console.log('设置：' + key) // 如果是对象，就递归添加 proxy 拦截\n          return Reflect.set(target, key, value, receiver)\n        }\n      }\n      return new Proxy(obj, handler)\n    }\n \n    let newObj = observerProxy(obj)\n")])])]),t("p",[e._v("1.Object.defineProperty 拦截的是对象的属性，会改变原对象。proxy 是拦截整个对象，通过 new 生成一个新对象，不会改变原对象。")]),e._v(" "),t("p",[e._v("2.proxy 的拦截方式，除了上面的 get 和 set ，还有 11 种。选择的方式很多 Proxy，也可以监听一些 Object.defineProperty 监听不到的操作，比如监听数组，监听对象属性的新增，删除等。")]),e._v(" "),t("p",[e._v("Object.defineProperty() 的问题主要有三个：")]),e._v(" "),t("ul",[t("li",[e._v("不能监听数组的变化")]),e._v(" "),t("li",[e._v("必须遍历对象的每个属性")]),e._v(" "),t("li",[e._v("必须深层遍历嵌套的对象")])]),e._v(" "),t("p",[e._v("Proxy 在 ES2015 规范中被正式加入，它有以下几个特点")]),e._v(" "),t("ul",[t("li",[e._v("针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题")]),e._v(" "),t("li",[e._v("支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。")])]),e._v(" "),t("p",[e._v("除了上述两点之外，Proxy 还拥有以下优势：")]),e._v(" "),t("ul",[t("li",[e._v("Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富")]),e._v(" "),t("li",[e._v("Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。")])]),e._v(" "),t("h2",{attrs:{id:"基于数据劫持双向绑定的实现思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于数据劫持双向绑定的实现思路"}},[e._v("#")]),e._v(" 基于数据劫持双向绑定的实现思路")]),e._v(" "),t("p",[e._v("基于数据劫持的双向绑定离不开"),t("code",[e._v("Proxy")]),e._v("与"),t("code",[e._v("Object.defineProperty")]),e._v('等方法对对象/对象属性的"劫持",我们要实现一个完整的双向绑定需要以下几个要点。')]),e._v(" "),t("ol",[t("li",[e._v("利用"),t("code",[e._v("Proxy")]),e._v("或"),t("code",[e._v("Object.defineProperty")]),e._v('生成的Observer针对对象/对象的属性进行"劫持",在属性发生变化后通知订阅者')]),e._v(" "),t("li",[e._v("解析器Compile解析模板中的"),t("code",[e._v("Directive")]),e._v("(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染")]),e._v(" "),t("li",[e._v("Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化")])])])}),[],!1,null,null,null);t.default=r.exports}}]);