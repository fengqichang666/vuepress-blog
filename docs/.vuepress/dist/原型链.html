<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原型链 | 前端笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="前端笔记">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.cccb21c6.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.c67c5da6.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.eeb24f79.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/37.34fe6535.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.5337bfd3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.43439a8b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/12.ef0ccc82.js"><link rel="prefetch" href="/vuepress-blog/assets/js/13.d45ceac6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.86f3b39f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.4ebef001.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.91e74913.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.e7522585.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.fd918a9f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.3658db2e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.a30074c1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.534b25a2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.06685893.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.902495c0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.9f672a51.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.841a83df.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.baf3e08e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.9aa320b3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.aaac7303.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.0c79d8a4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.4be1bc6c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.99505e93.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.419ffd3b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.2c8603dc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.9dce2642.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.4cca7072.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.cac668e7.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.f9699987.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.527afdac.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.743d4c06.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.f876ad59.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.ab97d810.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.7cfc49c1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.0194af80.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.024609eb.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.fedadfda.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.5361ccb6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.7c24424d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.2492cfa6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.47dc0462.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.18c5236f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.e86df8f9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/7.2c3ac2da.js"><link rel="prefetch" href="/vuepress-blog/assets/js/8.1a5c7481.js"><link rel="prefetch" href="/vuepress-blog/assets/js/9.a56e1dc1.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.cccb21c6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">前端笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>列表</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-blog/常用的正则表达式大全.html" class="sidebar-link">常用的正则表达式大全</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><img src="https://fengqichang666.github.io/images/prototype_chain.jpg" alt="原型链图"></p> <p>构造函数,原型和实例的关系:</p> <blockquote><p>每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.</p></blockquote> <blockquote><p>如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.</p></blockquote> <h3 id="原型链继承"><a href="#原型链继承" class="header-anchor">#</a> 原型链继承</h3> <div class="language- extra-class"><pre class="language-text"><code>问题1：原型中包含的引用类型属性将被所有实例共享；
问题2：子类在实例化的时候不能给父类构造函数传参；
function Animal() {
    this.colors = ['black', 'white']
}
Animal.prototype.getColor = function() {
    return this.colors
}
function Dog() {}
Dog.prototype =  new Animal()

let dog1 = new Dog()
dog1.colors.push('brown')
let dog2 = new Dog()
console.log(dog2.colors)  // ['black', 'white', 'brown']

</code></pre></div><h3 id="借用构造函数实现继承"><a href="#借用构造函数实现继承" class="header-anchor">#</a> 借用构造函数实现继承</h3> <div class="language- extra-class"><pre class="language-text"><code>//父类：人
    function Person () {
      this.head = '脑袋瓜子';
      this.emotion = ['喜', '怒', '哀', '乐']; //人都有喜怒哀乐
      this.eat = function () {
        console.log('吃吃喝喝');
      }
      this.sleep = function () {
        console.log('睡觉');
      }
      this.run = function () {
        console.log('快跑');
      }
    }
    //子类：学生，继承了“人”这个类
    function Student(studentID) {
      this.studentID = studentID;
      Person.call(this);
    }
    
    //Student.prototype = new Person();

    var stu1 = new Student(1001);
    console.log(stu1.emotion); //['喜', '怒', '哀', '乐']

    stu1.emotion.push('愁');
    console.log(stu1.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;, &quot;愁&quot;]
    们通过借用构造函数继承，保证了 stu1 和 stu2 都有各自的父类属性副本，从而使得各自 emotion 互不影响。但同时带来的问题是，stu1 和 stu2 都拷贝了 Person 类中的所有属性和方法，而在 Person 类中，像 eat ( ), sleep ( ), run ( ) 这类方法应该是公用的，而不需要添加到每个实例上去，增大内存，尤其是这类方法较多的时候。
    
    var stu2 = new Student(1002);
    console.log(stu2.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;]
</code></pre></div><h3 id="组合继承-结合使用两种继承模式"><a href="#组合继承-结合使用两种继承模式" class="header-anchor">#</a> 组合继承（结合使用两种继承模式）</h3> <div class="language- extra-class"><pre class="language-text"><code>方法挂载到父类的原型对象上去，实现方法复用，然后子类通过原型链继承
//父类：人
    function Person () {
      this.head = '脑袋瓜子';
      this.emotion = ['喜', '怒', '哀', '乐']; //人都有喜怒哀乐
    }
    //将 Person 类中需共享的方法放到 prototype 中，实现复用
    Person.prototype.eat = function () {
      console.log('吃吃喝喝');
    }
    Person.prototype.sleep = function () {
      console.log('睡觉');
    }
    Person.prototype.run = function () {
      console.log('快跑');
    }
    //子类：学生，继承了“人”这个类
    function Student(studentID) {
      this.studentID = studentID;
      Person.call(this);
    }
    
    Student.prototype = new Person();  //此时 Student.prototype 中的 constructor 被重写了，会导致 stu1.constructor === Person
    Student.prototype.constructor = Student;  //将 Student 原型对象的 constructor 指针重新指向 Student 本身

    var stu1 = new Student(1001);
    console.log(stu1.emotion); //['喜', '怒', '哀', '乐']

    stu1.emotion.push('愁');
    console.log(stu1.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;, &quot;愁&quot;]
    
    var stu2 = new Student(1002);
    console.log(stu2.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;]

    stu1.eat(); //吃吃喝喝
    stu2.run(); //快跑
    console.log(stu1.constructor);  //Student
    
    首先，我们将 Person 类中需要复用的方法提取到 Person.prototype 中，然后设置 Student 的原型对象为 Person 类的一个实例，这样 stu1 就能访问到 Person 原型对象上的属性和方法了。其次，为保证 stu1 和 stu2 拥有各自的父类属性副本，我们在 Student 构造函数中，还是使用了 Person.call ( this ) 方法。如此，结合原型链继承和借用构造函数继承，就完美地解决了之前这二者各自表现出来的缺点。
</code></pre></div><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="header-anchor">#</a> 寄生式组合继承</h3> <div class="language- extra-class"><pre class="language-text"><code>function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
    // 通过构造一个介于 Parent 与 Child 之间的对象，并使该对象的 prototype 属性指向 Parent 的 prototype对象，
    // 来避开通过调用 Parent 构造函数的方式来产生一个 prototype 指向Parent prototype对象的对象。
}

function prototype(child, parent) {
// 不直接child.prototype=parent.prototype呢？
// 原因 : 当我们想给 Child 的prototype里面添加共享属性或者方法时，如果其 prototype 指向的是 Parent 的 prototype，那么在 Child 的 prototype 里添加的属性和方法也会反映在 Parent 的 prototype 里面，
// 这明显是不合理的，这样做的后果是当我们只想使用 Parent 时，也能看见 Child 往里面扔的方法和属性。
// 所以需要每个构造函数都需要持有自己专用的prototype对象
    var prototype = object(parent.prototype);
    prototype.constructor = child;
    child.prototype = prototype;
}

prototype(Child, Parent);

var child1 = new Child('kevin', '18');

console.log(child1);
</code></pre></div><h3 id="class-实现继承"><a href="#class-实现继承" class="header-anchor">#</a> class 实现继承</h3> <div class="language- extra-class"><pre class="language-text"><code>class Animal {
    constructor(name) {
        this.name = name
    } 
    getName() {
        return this.name
    }
}
class Dog extends Animal {
    constructor(name, age) {
        super(name)
        this.age = age
    }
}
</code></pre></div><h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="header-anchor">#</a> 确定原型和实例的关系</h3> <blockquote><p>第一种是使用 <strong>instanceof</strong> 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回</p> <div class="language- extra-class"><pre class="language-text"><code>var d = new Date();
d instanceof Date;//=&gt;true  d是Date的实例
d instanceof Object;//=&gt;true 所有对象都是Object的实例
</code></pre></div><p>第二种是使用 <strong>isPrototypeOf()</strong> 方法, 同样只要是原型链中出现过的原型,isPrototypeOf() 方法就会返回true,</p> <div class="language- extra-class"><pre class="language-text"><code>var d = new Date();
Date.prototype.isPrototypeOf(d);//=&gt;true
Object.prototype.isPrototypeOf(d);//=&gt;true
</code></pre></div></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-blog/assets/js/app.c67c5da6.js" defer></script><script src="/vuepress-blog/assets/js/2.eeb24f79.js" defer></script><script src="/vuepress-blog/assets/js/37.34fe6535.js" defer></script>
  </body>
</html>
